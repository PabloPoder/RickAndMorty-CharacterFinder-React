# RICK AND MORTY: CHARACTER FINDER - useState, useEffect âš›ï¸
Este proyecto lo hice como ejercicio prÃ¡ctico para familiarizarme con el uso de useState, useEffect, custom hooks y otros componentes y funciones utiles en React.

# Visitar pÃ¡gina: ğŸ‘€
https://rickandmortycharacterfinder.surge.sh

# API: ğŸ‘¨ğŸ»â€ğŸ’»
https://rickandmortyapi.com/

# Lista de caracterÃ­sticas a desarrollar: ğŸ“

âœ… - Mostrar un input para buscar la pelÃ­cula y un botÃ³n para buscar. (El botÃ³n fue eliminado ya que la bÃºsqueda se convirtiÃ³ en automÃ¡tica).

âœ… - Listar los personajes encontrados y mostrar el nombre, especie e imagen.

âœ… - Realizar validaciÃ³n del formulario.

âœ… - Realizar fetch de datos.

âœ… - Hacer que los personajes se muestren en un grid responsive.

Primera iteraciÃ³n:

âœ… - Evitar que se realice la misma bÃºsqueda dos veces seguidas.

âœ… - Hacer que la bÃºsqueda se realice automÃ¡ticamente al escribir.

âœ… - Evitar que se realice la bÃºsqueda continuamente al escribir (debounce).




# Pasos que seguÃ­ para el desarrollo: ğŸ§©

1. CreÃ© la estructura HTML de la pÃ¡gina principal (main, h1, form, input, button).
2. CreÃ© un mock con los resultados de la API.
3. CreÃ© el componente Characters, el cual renderiza la lista o un mensaje dependiendo de si la lista estÃ¡ vacÃ­a o no.
4. AgreguÃ© mÃ¡s datos para mostrar, como la especie y el lugar de origen del personaje.
5. MapeÃ© la informaciÃ³n del JSON para guardarla segÃºn mis necesidades. De esta forma, la interfaz de usuario no queda anclada a la API.
6. CreÃ© un estado para la validaciÃ³n del formulario. El valor del estado lo seteo en el atributo "value" del input. TambiÃ©n creÃ© las funciones handleChange y handleSubmit. handleChange se encarga de no permitir empezar con un espacio vacÃ­o.
7. CreÃ© un custom hook para las validaciones del input.
8. CreÃ© un custom hook para los personajes.
9. CreÃ© un servicio para el fetching de datos y el mapeo de la respuesta.
10. Desde el custom hook useCharacters, llamÃ© al servicio y actualicÃ© el estado.
11. CreÃ© dos estados nuevos para el custom hook de characters: loading y error.
12. CreÃ© otro useRef para verificar si se estÃ¡ buscando con la misma query dos veces (es decir, la misma peticiÃ³n). Si es asÃ­, entonces no la realizo.
13. AgreguÃ© un estado para el ordenamiento (sort) y utilicÃ© useMemo en el custom hook para que sortedCharacters no se ejecute nuevamente.
